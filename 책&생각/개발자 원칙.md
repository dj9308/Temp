# 개발자 원칙

## 박성철 - 덕업일치를 넘어서

---

#### 쓸모 있는 소프트웨어를 만들자

- 전문가의 정의는 다음과 같다.
  `전문가 = (전문 역량 + 일반 역량) * 동기 * cosθ * 연대`
- 개발자는 지식 노동자로써, 성과를 내는 주체이며, 스스로 목표를 설정하고 달성하기 위해 자신을 경영해야 한다.
- 개발자를 양성하는 모든 교육 과정이 부족하며, 개발 과정에 대해서도 이제야 이해하는 수준이다.
- 언젠가는 개발자 호황기가 끝나고 실력으로 만들어내는 성과에 따라서 평가되는 때가 올 것이다.

이 글을 보고 나서 역량 뿐 아니라 자기 관리 및 커뮤니케이션 능력 또한 개발자의 필수 조건이라는 것을 다시 한번 깨닫게 된다.

또한 이직하고 난 뒤 안이함에 잠식되어 갈 때 즈음 필자의 글을 읽으니, 당연히 한참 더 공부해야 하는 것을 알았으며 한동안 이 책에서 나오는 문구가 기억날 것 같다.
`너는 아직 전문가가 아니다.`

필자가 겪었던 것과 느낀 점들을 내 상황과 비교해 봤다.
2022년 현재 나는 이직한지 두 달이 채 안된다. 아직 초창기라 팀에선 내 실력을 테스트하기 위해 OTJ 프로젝트를 지시한 상태이다. 

나는 널널한 기한과 그저 테스트라고 생각하며 적당히 일하고 적당히 적응했다. 또한 공부와 운동도 거의 손 놓았다.

자기 고백이긴 하지만 지금이라도 루틴을 다시 짜고 시작해야겠다. 전문가가 되기 위해.

## 강대명 - 오류를 만날때가 성장하기 가장 좋을 때다.

---

#### 오류가 발생하면 소스 코드 레벨에서 이해하자

- 오류를 검색 후 해결책을 얻는 것으로만 끝낸다면, 깊은 지식을 얻기 어렵다. 해당 툴의 소스 코드를 확인하는 것으로 관련 에러가 왜 발생하는지, 어떻게 해결해야하는지 같은 깊은 지식을 얻을 수 있다.

#### 알아낸 지식은 글로 공개해라.

- 자신이 공부하고 정리한 것을 온라인에 기록 및 공개를 하는 것이 좋다. 온라인에 공개하면 여러 고수들에게 피드백을 받을 수 있기 때문이다.
- 개발을 하며 순간마다 떠오르는 작은 의문들에 대해 깊이 아는 것이 크게 도움이 안 될 수도 있다.  하지만 각 질문에 대한 해답을 근본에서 확인하고 그것이 쌓이면 깊이 있는 기술력을 가질 수 있다.

필자는 지속적인 배움의 중요성과 즐거움을 강조한다. 또한 오류를 해결 할 때, 한 단계 더 파고드는 걸 추천하는데, 비슷한 경험으로 OTJ 프로젝트에서 JPA를 이용해 비즈니스 로직을 구성하는 도중, Transaction이 먹히지 않는 오류를 해결할 때이다.

당시 나는 구글링을 하며 원인 및 해결책을 찾아 오류를 해결했지만, 해결할 당시에는 필자가 추천하는 대로 소스 코드를 확인하지는 않았다. 이제 필자가 추천하는 대로, 소스 코드를 보며 원인을 찾으며 [JPA Transaction, Batch Insert](https://github.com/dj9308/Temp/blob/master/Spring/JPA%20Transaction%20%26%20Batch%20insert.md)에 정리했다.

## 공용준 - 소프트웨어 디자인 원칙

---

- 이전 몇 세대부터 고착된 프로그램 원칙이 몇 가지 존재하는데, 대표적인 것이 다음과 같다.
  - 코딩 자체에 대한 원칙
  - 객체 지향 프로그래밍에서 많이 회자되는 SOILD 원칙
  - 해당 원칙이 지켜지지 않았을 때 나오는 디자인 악취
- 원칙이 만들어지고 약 20년이 지난 지금, 해당 원칙들을 그대로 받아들여야 하는지는 생각해봐야 한다. 그 이유는 다음과 같다.
  -  '소프트웨어 디자인'에 대한 정의가 없기 때문이다. 정의를 내리지도 않았는데 디자인 원칙을 거론하는 것은 상관/인과 관계가 없는 설명이다.
  - 원칙이라고 붙이기에는 이론적 근거가 거의 없다.
  - 여기서 말하는 디자인 악취는 원인이 아니고 결과이다. 결과가 아닌 원인을 제거해야 한다.
- 프로그래밍 자체에 적용되는 원칙, 그 다음 단계라 할 수 있는 객체 지향 프로그래밍에 대한 원칙도 중요하지만, 이런 원칙이 훌륭한 소프트웨어 제품으로 연결되는 것은 아니므로 제품이 잘 완성될 수 있게 하는 '디자인 원칙'이 반드시 필요하다.

#### 디자인이란 무엇인가

- 대부분의 개발자들에게 '디자인은 무엇인가 '라고 질문을 하면 대부분 제대로 설명하지 못한다.
- 사전적 단어 설명 중 '건축물 설립이나 토지 공사, 기계의 제작 따위에서 그 목적에 따라 실제적인 계획을 세우고 구체적으로 도면을 그려 넣는 일'이 비교적 소프트웨어 제품을 개발할 때 적용해 볼 수 있다.
- '실제적인 계획'을 소프트웨어 개발에 적용해 볼 때, 간트 차트나 WBS 등 소프트웨어 개발에도 적용 가능하거나 실제로 사용되는 구체적인 예시들이 존재한다.
- 그에 비해 '구체적인 도면'을 소프트웨어 개발에 적용하는 것은 어렵다.
  - 설계 및 제작 도구의 표준화 및 단일화 측면으로 볼 때, 소프트웨어 제품은 아직 설계 및 제작과 관련된 표준이 없다.
  - 소프트웨어 개발을 자유롭고 민첩하게 만들면 모든 문제가 해결된다는 근거 없는 주장을 믿는 사람들의 영향이 크다고 생각한다.
  - 해당 문제를 해결하기 위해 UML을 작성하지만, 다음과 같은 문제 때문에 UML은 거의 사용하지 않는다.
    1. UML을 작성해도 실행 가능한 소프트웨어를 구현하려면 또 다른 과정이 필요하다.
    2. UML 설계 자료를 제공해 위탁 개발했을 때, 같은 소프트웨어 제품을 만든다는 보장이 없다.
    3. UML이 커질 경우, 적절히 동작하지 못하고, 코드 수정이 반영될 때까지 너무 오래 걸린다. 
- 이러한 이유로 현재 소프트웨어 설계 수준은 2000년대 초반에 머물러 있으며, 설계를 하는 소프트웨어나 방법이 없다.

#### 설계와 요구사항

- 제품이란 다른 사람들의 요구를 충족시켜 주는 것이다. 또한 설계는 제품이 요구사항을 만족시켜 주는 것을 증명하는 조건을 정의하는 것이다. 때문에 제품을 잘 만들려면 요구사항을 잘 정의해야 한다.
- 제품을 만드는 생산자라도 어떤 제품을 만들지 명확하게 알고 소비자에게 알려줘야 할 때도 있다.
- 요구사항이 정해지면, 설계 단계에서는 만들 제품이 주어진 요구사항을 잘 충족하는지 증명할 수 있는 조건을 정의해야 한다.  이러한 설계 과정에서 추상적인 설계나 개념이 측정할 수 있는 숫자적 개념으로 바뀌게 된다.
- 설계 조건이 정해지면 테스트에 필요한 조건도 정확하게 정해지기 때문에, 테스트 계획이나 조건은 당연한 결과물이다. 때문에 설계에는 테스트 주도 개발(TDD), 동작 주도 개발(BDD), 도메인 주도 개발(DDD) 개념이 들어가 있다.
- 하지만 개발은 주로 코드를 작성하는 것을 의미하며 제품을 생산하는 것에 가깝기 때문에 테스트와 동작은 주로 설계의 서브 개념이나 결과물에 가깝다.
- 설계를 하다 보면 미리 갖춰야 할 선행 조건 역시 자연스럽게 파악할 수 있게 된다. 이를 기본 사항 또는 환경이라 한다.
- 소프트웨어를 설계할 때 최대한 많은 정보를 기반으로 요구사항을 정리해야 한다. 하지만 대체로 기획자가 개발에 필요한 정보를 구체적으로 소프트웨어 요구사항 명세(SRS)에 기술하기는 한계가 있다.
- SRS를 만든 후엔 정리한 요구사항을 바탕으로 제품이 가져야 할 특성을 종합적이고 전체적으로 설계해야 한다. 제품을 종합적으로 설계하는 방법은 명시적(외제적) 설계와 암묵적(내재적) 설계가 있다. 나누는 기준은 산출물들이 SRS나 기본 요구사항에 직접 연결되는지 여부이다.  



## 책에서 나오는 프로그래밍 기본 지식

### 작은 단위의 코드에 적용되는 원칙

- KISS(Keep It Simple, Stupid) : 간단하게 class나 method를 만들 것.
- DRY(Do nnot Repeart Yourself) : 반복되는 기능이나 객체를 하나로 만들어서 관리할 것.
- YAGNI(You Ain't Gonna Need It) : 코드를 적어나가다 보면 갑자기 머릿속에서 떠오르는 필요한 기능이 있어서 적지만 안 쓴다.

### 객체 지향 프로그래밍에서 적용되는 원칙

- SRP(Single Responsibility Principle, 단일 책임 원칙) : 각 클래스는 하나의 정보만을 만들어야 하고, 각 클래스에서 공통적인 특성을 추출할 수 있다면 하나의 부모 클래스로 옮긴 다음 변화하는 특성만 상속이나 구현으로 처리하는 원칙. 
- OCP(Open Closed Principle, 개방 폐쇄 원칙) : 확장에는 열려있으며, 변경에는 닫혀있어야 하는 법칙.
- LSP(Listov Substitution Princle, 리스코프 치환 법칙) : 인터페이스의 서브 타이핑은 인터페이스에 정의된 형태를 최대한 유지해야 하는 법칙.
- ISP(Interface Segregation Principle, 인터페이스 분리 법칙) : 인터페이스는 최소한으로 유지하라는 법칙.
- DIP(Dependency Inversion Principle, 의존 관계 역전 법칙) : 상위 레벨의 모듈이나 인터페이스가 서브 클래스나 타이핑에 영향을 받아선 안된다는 법칙

